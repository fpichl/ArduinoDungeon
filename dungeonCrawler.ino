#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>

// definitions for button IDs
#define BTN_UP        1
#define BTN_DOWN      2
#define BTN_LEFT      3
#define BTN_RIGHT     4
#define BTN_INVENTORY 5
#define BTN_ATTACK    6
#define BTN_REST      7
#define BTN_ANY       8

// definitions for weapons. Weapon ID = damage
#define WPN_HANDS 1
#define WPN_SWORD 3
#define WPN_MAGIC 5

// definitions for Armour. Armour ID = protection value
#define ARM_TUNIC 0
#define ARM_CHAIN 1
#define ARM_PLATE 2

#define ACTOR_AMOUNT 5

// Initialize display with correct controller, size, buffer size and
// communication protocol. The manual for the display specified this constructor
//U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE); // keep whole frame in buffer until cleared
//U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE); // keep only one page in buffer
U8G2_SH1106_128X64_NONAME_2_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE); // keep two pages in buffer

// Player variables
uint8_t player_posx = 1;
uint8_t player_posy = 1;
uint8_t player_weapon = WPN_HANDS;
uint8_t player_armour = ARM_TUNIC;
uint8_t player_health = 8;
uint8_t player_lives = 3;
bool player_haskey = false;

// Define sprites for actors as bitmaps. Generated by convert.py. It would have
// been preferable to just make these class attributes but that complicates
// things immensely
static unsigned char sprite_wall[]     {0x00, 0x7b, 0x7b, 0x7b, 0x00, 0x6f, 0x6f, 0x6f};
static unsigned char sprite_player[]   {0x00, 0x1c, 0x1c, 0x08, 0x3e, 0x5d, 0x14, 0x36};
static unsigned char sprite_skull[]    {0x00, 0x3e, 0x5b, 0x7f, 0x2b, 0x03, 0x56, 0x7c};
static unsigned char sprite_nosprite[] {0x00, 0x29, 0x5b, 0x2d, 0x00, 0x57, 0x22, 0x52};
static unsigned char sprite_sword[]    {0x00, 0x40, 0x2e, 0x1c, 0x34, 0x3e, 0x27, 0x03};
static unsigned char sprite_empty[]    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static unsigned char sprite_door_on[]  {0x00, 0x3e, 0x41, 0x41, 0x5d, 0x55, 0x5d, 0x41};
static unsigned char sprite_door_cd[]  {0x00, 0x3e, 0x41, 0x41, 0x41, 0x5d, 0x41, 0x41};
static unsigned char sprite_key[]      {0x00, 0x00, 0x00, 0x07, 0x7d, 0x57, 0x00, 0x00};
static unsigned char sprite_magic[]    {0x00, 0x64, 0x6c, 0x18, 0x38, 0x64, 0x02, 0x01}; // unused
static unsigned char sprite_hands[]    {0x0e, 0x7a, 0x83, 0x60, 0x80, 0x60, 0x81, 0x7e};
static unsigned char sprite_tunic[]    {0x00, 0x22, 0x77, 0x7f, 0x7f, 0x3e, 0x3e, 0x3e};
static unsigned char sprite_chain[]    {0x00, 0x22, 0x5d, 0x6b, 0x55, 0x2a, 0x14, 0x2a};
static unsigned char sprite_plate[]    {0x00, 0x22, 0x77, 0x7f, 0x77, 0x22, 0x36, 0x3e}; // unused
static unsigned char sprite_ghost[]    {0x00, 0x3e, 0x6b, 0x7f, 0x6b, 0x55, 0x7f, 0x55};

// Define UI heart as bitmap
static unsigned char sprite_heart[]    {0x1b, 0x1f, 0x1f, 0x0e, 0x04};

// Define levels as bitmaps. Generated by convert.py
static unsigned char level_level0[]    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static unsigned char level_level1[]    {0xff, 0x89, 0x81, 0x89, 0xb9, 0xbd, 0xa1, 0xa1, 0xbb, 0xb9, 0xbd, 0x85, 0xb5, 0x91, 0x91, 0xff};
static unsigned char level_level2[]    {0xff, 0x81, 0x81, 0x81, 0xef, 0x81, 0xbd, 0x85, 0xa5, 0xbd, 0x81, 0xf7, 0x91, 0x95, 0x85, 0xff};
static unsigned char level_level3[]    {0xff, 0x91, 0x91, 0x91, 0x9b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0xeb, 0x81, 0x81, 0xff};

// level counter. There are 3 levels: 1, 2, 3. Level 0 and 4 are special.
uint8_t cur_level = 0;

// Returns current wall bitmap
unsigned char * getWalls(){
  switch (cur_level) {
    case 0: return level_level0;
    case 1: return level_level1;
    case 2: return level_level2;
    case 3: return level_level3;
  }
}

// Checks wether there is a wall at (x|y)
bool isWall(uint8_t x, uint8_t y){
  return ((getWalls()[x] >> y) & 0x01);
}

// A structure to store information about an actor.
struct Actor{
  uint8_t damage = 0;
  uint8_t health = 0;
  uint8_t type = 0; // dictates behaviour/sprite of the actor
  uint8_t subtype = 0;

  uint8_t cur_x = 0; // current x position
  uint8_t cur_y = 0; // current y position
  uint8_t old_x = 0; // previous x position
  uint8_t old_y = 0; // previous y position

  // A setter for all important attributes
  void setup(uint8_t x, uint8_t y, uint8_t type, uint8_t subtype = 0){
    this->old_x = x;
    this->old_y = y;
    this->cur_x = x;
    this->cur_y = y;
    this->type = type;
    this->subtype = subtype;

    switch (type){
      case 4:
        this->health = 4;
        this->damage = 2;
        break;
      case 6:
        this->health = 6;
        this->damage = 3;
        break;
    }
  }

  void blink(){
    // quickly hide and show an actor to convey something (e.g. an actor being hit)
    // this is done by setting their type to 0
    uint8_t saved_type = type;
    type = 0;
    for (int i = 0; i <= 4; i++){
      draw();
      if (type)
        type = 0;
      else
        type = saved_type;
    }
  }
  
  void takeDamage(int damage){
    // reduces health of actor and sets type to zero if health falls below zero
    blink();

    if ((health - damage) <= 0 ){
      type = 0;
      draw();
    } else {
      health -= damage;
    }
  }

  unsigned char * getSprite(){
    // return Sprite of actor
    switch(type){
    case 0:
      return sprite_nosprite;
    case 1:
      return sprite_empty;
    case 2:
      return sprite_key;
    case 3:
      if (player_haskey)
        return sprite_door_on;
      else
        return sprite_door_cd;
    case 4:
      return sprite_skull;
    case 5:
      return sprite_sword;
    case 6:
      return sprite_ghost;
    case 7:
      return sprite_magic; // unused
    case 8:
      return sprite_chain;
    case 9:
      return sprite_plate; // unused
    }
  
    return sprite_nosprite;
  }

  void setPosition(uint8_t new_x, uint8_t new_y){
    // sets position of actor
    this->old_x = cur_x;
    this->old_y = cur_y;
    this->cur_x = new_x;
    this->cur_y = new_y;
  }

  bool move(int8_t x_offset, int8_t y_offset){
    // sets position relative to current position
    if (!isWall(cur_x + x_offset, cur_y + y_offset)){
      old_x = cur_x;
      old_y = cur_y;
      cur_x += x_offset;
      cur_y += y_offset;

      return true;
    } else return false;
  }
  
  // shortcuts for move
  bool moveLeft(){
    return move((old_y-cur_y)*-1, old_x-cur_x);}
  bool moveRight(){
    return move(old_y-cur_y, (old_x-cur_x)*-1);}
  bool moveAhead(){
    return move(cur_x-old_x, cur_y-old_y);}
  bool moveBack(){
    return move(old_x-cur_x, old_y-cur_y);}

  // shortcuts for isWall
  bool wallLeft(){
    return isWall(cur_x+(old_y-cur_y)*-1, cur_y+old_x-cur_x);}
  bool wallRight(){
    return isWall(cur_x+old_y-cur_y, cur_y+(old_x-cur_x)*-1);}
  bool wallAhead(){
    return isWall(cur_x+cur_x-old_x, cur_y+cur_y-old_y);}

  // called every round
  void act(){
    if (type == 4){ // skull enemy

      // check wether player is next to actor
      if (((abs(cur_x - player_posx) <= 1) && (abs(cur_y - player_posy) == 0)) ||
          ((abs(cur_x - player_posx) == 0) && (abs(cur_y - player_posy) <= 1))){
        damagePlayer(damage);
      } 
      
      else if (old_x == cur_x && old_y == cur_y){
        if (!move(1, 0))
          if (!move(0, -1))
            if (!move(-1, 0))
              move(0, 1);
      }
      
      else {
        if (wallLeft() && wallRight()){
          if (!moveAhead())
            moveBack();

        } else if (wallLeft() && wallAhead()){
          if (!moveRight())
            moveBack();

        } else if (wallRight() && wallAhead()){
          if (!moveLeft())
            moveBack();

        } else if (wallRight()) {
          if (random(0,2))
            moveLeft();
          else moveAhead();

        } else if (wallLeft()) {
          if (random(0,2))
            moveRight();
          else moveAhead();

        } else if (wallAhead()) {
          if (random(0,2))
            moveRight();
          else moveLeft();

        } else if (random(0,2)){
          if (random(0,2))
            moveRight();
          else moveLeft();

        } else moveAhead();
          
      }
    } else if (type == 2){ // key
      if (cur_x == player_posx && cur_y == player_posy){
        player_haskey = true;
        type = 0;
      }
    } else if (type == 3) { // door
      if (cur_x == player_posx && cur_y == player_posy && player_haskey){
        player_haskey = false;
        cur_level++;
        setUpLevel();
      }
    } else if (type == 6) { // ghost enemy
      if (((abs(cur_x - player_posx) <= 1) && (abs(cur_y - player_posy) == 0)) ||
          ((abs(cur_x - player_posx) == 0) && (abs(cur_y - player_posy) <= 1))){
        damagePlayer(damage);
      } else if (cur_x == old_x && cur_y == old_y) {
        if (subtype == 1) {
          move(0, 1);
        } else {
          move(0, -1);
        }
      } else if (not moveAhead()) {
        moveLeft();
      }
    } else if (type == 5 || type == 7 || type == 8 || type == 9){ // armour and weapons
      if (cur_x == player_posx && cur_y == player_posy){
        // set player_weapon according to what the player is standing on
        switch (type){
          case 5:
            player_weapon = WPN_SWORD;
            break;
          case 7:
            player_weapon = WPN_MAGIC;
            break;
          case 8:
            player_armour = ARM_CHAIN;
            break;
          case 9:
            player_armour = ARM_PLATE;
            break;
        }
        type = 0;
      }
    }
  }
};

// Contains Enemies/Items
Actor actors[ACTOR_AMOUNT];

void damagePlayer(int8_t damage){
  // damages the player, subtracted by player armour

  damage -= player_armour;

  // no need to do anything if the armor blocks all damage
  if (damage <= 0)
    return;
  if (player_health - damage > 0)
    player_health -= damage;
  else {
    // reduce player lives if damage kills player
    player_health = 8;
    player_lives -= 1;

    // showDeathScreen handles the case of zero lives left
    showDeathScreen(player_lives <= 0);
    delay(5000);
    setUpLevel();
  }
}

bool playerAct(){
  // process player input

  // move player if there is no wall
  if (getButtonPress(BTN_UP) && !(isWall(player_posx, player_posy-1)))
    player_posy--;
  else if (getButtonPress(BTN_DOWN) && !(isWall(player_posx, player_posy+1)))
    player_posy++;
  else if (getButtonPress(BTN_RIGHT) && !(isWall(player_posx+1, player_posy)))
    player_posx++;
  else if (getButtonPress(BTN_LEFT) && !(isWall(player_posx-1, player_posy)))
    player_posx--;

  // let the player attack
  else if (getButtonPress(BTN_ATTACK)){
    return playerAttack();

  // Do nothing, rest and let the other actors act
  } else if(getButtonPress(BTN_REST)){
    return true;

  // open player inventory
  } else if(getButtonPress(BTN_INVENTORY)){
    playerOpenInventory();
    return false;

  } else return false;

  return true;
}

bool playerAttack(){
  // used for checking wether the player actually hit an enemy
  // if they didn't, the actors should not act
  bool attacked_successfully = false;
  
  for (int i = 0; i <4; i++){
    // ignore not initialized / irrelevant actors
    if (!(actors[i].type == 4 || actors[i].type == 6))
      continue;
    
    // check if an actor is 1 space away (not counting diagonally)
    if ((abs(actors[i].cur_x - player_posx) <= 1) && (abs(actors[i].cur_y - player_posy) == 0) || 
        (abs(actors[i].cur_y - player_posy) <= 1) && (abs(actors[i].cur_x - player_posx) == 0)){
      attacked_successfully = true;

      // damage the actor. It will blink to let the player know they hit something
      actors[i].takeDamage(player_weapon);
    }
  }

  // the actors should not act if no one was hit
  if (!attacked_successfully)
    return false;

  return true;
}

void playerOpenInventory(){
  // opens inventory. The Inventory is a black box showing weapon, armour and
  // wether the player has a key

  u8g2.firstPage();
  do {
    // Draw walls
    for (int x = 0; x <= 15; x++){
  
      unsigned char cur_char = getWalls()[x];
      for (int y = 0; y <= 8; y++){
        if (cur_char & 0x01) // bit wise "and". Checks rightmost bit
          u8g2.drawXBM(x*8, y*8, 8, 8, sprite_wall);
        cur_char = cur_char >> 1; // Bitshift to the right
      }
    }

    // Draw borders
    u8g2.setDrawColor(0);
    u8g2.drawBox(18, 11, 88, 40);
    u8g2.setDrawColor(1);
    u8g2.drawFrame(18, 11, 88, 40);

    // Draw Armour and Weapon Text
    u8g2.setFont(u8g2_font_5x7_tr);
    u8g2.drawStr(21, 22, "Weapon:");
    u8g2.drawStr(26, 35, "Armor:");

    // draw weapon
    switch (player_weapon){
      case WPN_HANDS:
        u8g2.drawStr(58, 22, "Hands");
        u8g2.drawXBM(90, 15, 8, 8, sprite_hands);
        break;
      case WPN_SWORD:
        u8g2.drawStr(58, 22, "Sword");
        u8g2.drawXBM(90, 15, 8, 8, sprite_sword);
        break;
      case WPN_MAGIC:
        u8g2.drawStr(58, 22, "L. Sword");
        u8g2.drawXBM(90, 15, 8, 8, sprite_magic);
        break;
    }

    // draw armour
    switch (player_armour){
      case ARM_TUNIC:
        u8g2.drawStr(58, 35, "Tunic");
        u8g2.drawXBM(90, 28, 8, 8, sprite_tunic);
        break;
      case ARM_CHAIN:
        u8g2.drawStr(58, 35, "Chain");
        u8g2.drawXBM(90, 28, 8, 8, sprite_chain);
        break;
      case ARM_PLATE:
        u8g2.drawStr(58, 35, "Plate");
        u8g2.drawXBM(90, 28, 8, 8, sprite_plate);
        break;
    }

    // Draw wether the player has a key
    if (player_haskey)
      u8g2.drawXBM(22, 41, 8, 8, sprite_key);
    
  } while (u8g2.nextPage());

  // close inventory when the player presses a button
  do {
    delay(150);
  } while (!getButtonPress(BTN_INVENTORY));

  draw();
}

void setUpLevel(){
  // depending on current level, set up the actors and the player

  player_haskey = false;

  switch (cur_level){
    case 1:
      player_posx = 1;
      player_posy = 1;

      actors[0].setup(11, 1, 4); // skull
      actors[1].setup(14, 6, 2); // key
      actors[2].setup(6, 4, 3); // door
      actors[3].setup(0, 0, 0);
      actors[4].setup(0, 0, 0);
      break;

    case 2:
      player_posx = 1;
      player_posy = 1;

      actors[0].setup(5, 2, 6, 1); // left ghost
      actors[1].setup(10, 5, 6, 0); // right ghost
      actors[2].setup(14, 1, 2); // key
      actors[3].setup(8, 3, 3); // door

      if (player_weapon != WPN_SWORD)
        actors[4].setup(13, 6, 5); // sword
      else
        actors[4].setup(0, 0, 0);

      break;

    case 3:
      player_posx = 2;
      player_posy = 2;

      actors[0].setup(1, 3, 2); // key
      actors[1].setup(1, 6, 3); // door
      actors[2].setup(10, 5, 4); // right skull
      actors[3].setup(7, 5, 4); // left skull
      actors[4].setup(14, 2, 8); // chain armour

      break;

    case 4: // level 4 is just the end screen
      showEndScreen();
  }
}

void draw(){
  // draws the current scene with walls, actors and the player

  // set current page to first page
  u8g2.firstPage();
  do {
    // Draw walls by iterating over bits in chars
    for (int x = 0; x <= 15; x++){

      unsigned char cur_char = getWalls()[x];
      cur_char = cur_char >> 1;  // Bitshift to the right
      
      for (int y = 1; y <= 8; y++){
        if (cur_char & 0x01) // bit wise "and". Checks rightmost bit
          u8g2.drawXBM(x*8, y*8, 8, 8, sprite_wall);
        cur_char = cur_char >> 1;  // Bitshift to the right
      }
    }

    // Draw Player
    u8g2.drawXBM(player_posx*8, player_posy*8, 8, 8, sprite_player);

    // Draw actors
    for (Actor actor : actors)
      if (actor.type != 0)
        u8g2.drawXBM(actor.cur_x*8, actor.cur_y*8, 8, 8, actor.getSprite());

    // Draw UI
    u8g2.drawHLine(0, 6, 126);
    u8g2.drawHLine(0, 7, 126);
    u8g2.setFont(u8g2_font_blipfest_07_tr);
    u8g2.drawStr(0, 5, "HP:");
    for (uint8_t hp = 1; hp <= 8; hp++){
      if (hp <= player_health)
        u8g2.drawDisc(10+6*hp, 2, 2);
      else
        u8g2.drawCircle(10+6*hp, 2, 2);
    }
    for (uint8_t hearts = 0; hearts < player_lives; hearts++)
      u8g2.drawXBM(118-hearts*6, 0, 5, 5, sprite_heart);

  } while (u8g2.nextPage());
}

void setup() {
  // set up everything necessary 

  // a set seed is easier for testing / showcasing
  randomSeed(123);

  // initialize display
  u8g2.begin();

  // show start and help screen once
  showStartScreen();
  showHelpScreen();

  // set current level
  cur_level = 1;

  // set up first level
  setUpLevel();

  // draw the initial level
  draw();
}

void loop() {
  // main loop of application

  // don't continue if the player is doing nothing
  while (!playerAct()){
    delay(10);
  }

  // iterate over actors and let them act
  for (int i = 0; i < ACTOR_AMOUNT ; i++)
    actors[i].act();

  // draw changes
  draw();

  // delay so that the player can hold the joystick without the game reaching super speeds
  delay(200);
}

void showHelpScreen(){
  // draw help screen

  // delay so that this isn't skipped accidentally
  delay(500);
  
  // bitmap for joystick image
  static unsigned char joyStick[]{0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x80, 0xff, 0x00, 0x80, 0xff, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x3e, 0x00, 0x08, 0x7f, 0x08, 0x8c, 0xbe, 0x18, 0xbe, 0x80, 0x3e, 0x0c, 0x7f, 0x18, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x08, 0x00};

  // controls blinking of instruction for continuing
  bool show_hint = true;
  bool switch_show_hint = false;

  do {
    // set current page to first page
    u8g2.firstPage();
    do { // draw various text and images
      u8g2.setFont(u8g2_font_tenfatguys_tr);
      u8g2.drawStr(8,15,"How To Play");
      u8g2.setFont(u8g2_font_5x7_tr);
  
      u8g2.drawXBM(18, 27, 24, 16, joyStick);
      u8g2.drawStr(20, 52, "Move");
  
      u8g2.drawDisc(68, 29, 3, U8G2_DRAW_ALL);
      u8g2.drawStr(73, 29, "Inventory");
      
      u8g2.drawDisc(61, 36, 3, U8G2_DRAW_ALL);
  
      u8g2.drawCircle(75, 36, 3, U8G2_DRAW_ALL);
      u8g2.drawStr(81, 40, "Attack");
      
      u8g2.drawCircle(68, 43, 3, U8G2_DRAW_ALL);
      u8g2.drawStr(74, 49, "Rest");
  
      u8g2.setFont(u8g2_font_tom_thumb_4x6_tr);
      if (show_hint) // this adds a blinking effect to the instruction
        u8g2.drawStr(7, 63, "Press any button to continue");
  
    } while (u8g2.nextPage());

    // controls when the instruction text disappears (for blinking effect)
    // switch between showing and not showing every second loop
    if (switch_show_hint)
      show_hint = !show_hint;
    switch_show_hint = !switch_show_hint;

    // delay for timing the blinking correctly
    // return when palyer presses a button
    for (int i = 0; i < 4; i++){
      if (getButtonPress(BTN_ANY))
        return;
      delay(50);
    }
  } while (true);
}

void showStartScreen(){
  // draw start screen

  // offset is added to y position of title text.
  // The value rises and falls
  int8_t offset = 0;
  bool rising = false;

  do {
    // set current page to first page
    u8g2.firstPage();
    do {
      // draw title. Add offset for "floating" effect
      u8g2.setFont(u8g2_font_HelvetiPixelOutline_tr);
      u8g2.drawStr(20,15+offset,"ARDUINO");
      u8g2.drawStr(20,30+offset,"DUNGEON");

      // draw instruction for continuing
      u8g2.setFont(u8g2_font_5x7_tr);
      u8g2.drawStr(30, 55, "Press Start");
  
    } while (u8g2.nextPage());

    // change offset value. It should rise and fall
    if (rising and offset > 0)
      offset--;
    else if (!rising and offset < 5)
      offset++;
    else
      rising = !rising;

    // delay so that the floating effect has the proper speed
    for (int i = 0; i < 4; i++){
      if (getButtonPress(BTN_ANY))
        return;
      delay(50);
    }
  } while (true);
}

void showEndScreen(){
  // reset player variables
  player_weapon = WPN_HANDS;
  player_armour = ARM_TUNIC;
  player_health = 8;
  player_lives = 3;
  player_haskey = false;
  
  // reset level counter
  cur_level = 1;

  // Draw winning message. Restart if player presses a button
  u8g2.firstPage();
  do { // draw various text and images
    u8g2.setFont(u8g2_font_tenfatguys_tr);
    u8g2.drawStr(18,15,"Good Job!");

    u8g2.setFont(u8g2_font_5x7_tr);
    u8g2.drawStr(17, 32, "You beat the game!");
    u8g2.drawStr(15, 42, "Thanks for playing!");
    u8g2.drawStr(0, 52, "To restart, press any key");

  } while (u8g2.nextPage());
  while (!getButtonPress(BTN_ANY))
    delay(50);

  delay(200);
  showStartScreen();
  showHelpScreen();
  setUpLevel();
}

void showDeathScreen(bool gameOver){
  u8g2.firstPage();
  do {
    // Draw walls
    for (int x = 0; x <= 15; x++){

      unsigned char cur_char = getWalls()[x];
      for (int y = 0; y <= 8; y++){
        if (cur_char & 0x01) // bit wise "and". Checks rightmost bit
          u8g2.drawXBM(x*8, y*8, 8, 8, sprite_wall);
        cur_char = cur_char >> 1; // Bitshift to the right
      }
    }

    // Draw death message with box
    u8g2.setDrawColor(0);
    u8g2.drawBox(0, 23, 124, 24);
    u8g2.setDrawColor(1);
    u8g2.drawFrame(0, 23, 124, 24);
    u8g2.setFont(u8g2_font_lucasarts_scumm_subtitle_o_tr);
    if (gameOver)
      u8g2.drawStr(10, 42, "GAME OVER");
    else
      u8g2.drawStr(20, 42, "YOU DIED");
  } while (u8g2.nextPage());

  if (gameOver){
    // if game over, make everything black except for the text. Then move it up
    delay(2000);

    u8g2.firstPage();
    do {
      u8g2.drawStr(10, 42, "GAME OVER");
    } while (u8g2.nextPage());

    delay(1000);

    for (uint8_t y = 42; y > 20; y = y-2){
      u8g2.firstPage();
      do {
        u8g2.drawStr(10, y, "GAME OVER");
      } while (u8g2.nextPage());
    }

    delay(1000);
      
    // reset player variables
    player_weapon = WPN_HANDS;
    player_armour = ARM_TUNIC;
    player_health = 8;
    player_lives = 3;
    player_haskey = false;
    
    // reset level counter
    cur_level = 1;

    // show final game over message. Restart if player inputs something
    u8g2.firstPage();
      do {
        u8g2.setFont(u8g2_font_lucasarts_scumm_subtitle_o_tr);
        u8g2.drawStr(10, 22, "GAME OVER");
        u8g2.setFont(u8g2_font_tom_thumb_4x6_tr);
        u8g2.drawStr(13, 43, "Press any key to continue");
      } while (u8g2.nextPage());
    while (!getButtonPress(BTN_ANY))
      delay(50);

    delay(200);
    showStartScreen();
    showHelpScreen();
    setUpLevel();

  }
}

bool getButtonPress(int button){
  // Returns wether a given button is pressed
  int joystick_y = analogRead(A0);
  int joystick_x = analogRead(A1);
  
  switch (button){
    case BTN_UP:
      return joystick_y > 800 && !(joystick_x < 200) && !(joystick_x > 800);
    case BTN_DOWN:
      return joystick_y < 200 && !(joystick_x < 200) && !(joystick_x > 800);
    case BTN_LEFT:
      return joystick_x < 200 && !(joystick_y < 200) && !(joystick_y > 800);
    case BTN_RIGHT:
      return joystick_x > 800 && !(joystick_y < 200) && !(joystick_y > 800);
    case BTN_INVENTORY:
      return !digitalRead(2);
    case BTN_ATTACK:
      return !digitalRead(3);
    case BTN_REST:
      return !digitalRead(4);
    case BTN_ANY:
      return !digitalRead(2) || !digitalRead(3) || !digitalRead(4);

    return false;
  }
}
