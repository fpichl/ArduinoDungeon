%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,ngerman]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{Arduino Projekt Fabian Pichl}
\date{15.06.2021}
\release{}
\author{Fabian Pichl}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Ziel dieses Projektes ist das Entwickeln eines rundenbasierten Spieles des
„Dungeon Crawler“ Genres. Der Spieler kann sich bewegen, Gegner angreifen und
Gegenstände aufheben.

Dieses Spiel läuft auf einem Arduino Nano. Eingaben erfolgen mittels
eines Gamepads, die Darstellung mittels eines OLED Displays.

Im Folgenden werden alle notwendigen Schritte zum Nachbilden beschrieben.


\chapter{Installation und Vorbereiten benötigter Software}
\label{\detokenize{installation:installation-und-vorbereiten-benotigter-software}}\label{\detokenize{installation::doc}}
Bevor mit der Entwicklung des Projektes begonnen werden kann, müssen einige
Programme installiert werden. In dieser Anleitung wird dabei davon ausgegangen,
dass Ubuntu 18.04 oder Windows 10 als Betriebssystem verwendet werden. Das
Nachbilden unter Verwendung anderer Betriebssysteme ist möglich, wird hier aber
nicht berücksichtigt.


\section{Installation und Einrichtung der Arduino Entwicklungsumgebung}
\label{\detokenize{installation:installation-und-einrichtung-der-arduino-entwicklungsumgebung}}
Unter \sphinxurl{https://www.arduino.cc/en/software} kann die Arduino IDE heruntergeladen
werden. Dabei ist darauf zu achten, das korrekte Betriebssystem und die
korrekte Architektur zu wählen.

Nach der Installation der Entwicklungsumgebung muss die Bibliothek u8g2
heruntergeladen werden. Dazu wird die Entwicklungsumgebung gestartet. Nun wählt
man unter „Werkzeuge“ den Bibliotheksverwalter aus und sucht dort nach „U8g2“.
Es werden mehrere Bibliotheken vorgeschlagen, von denen ausschließlich die mit
dem Titel „U8g2“ heruntergeladen wird. Zum Zeitpunkt des Schreibens ist die
aktuellste Version 2.27.6.


\section{Verwenden einer Bildbearbeitungs\sphinxhyphen{} und Konvertierungssoftware}
\label{\detokenize{installation:verwenden-einer-bildbearbeitungs-und-konvertierungssoftware}}
Um Akteure, Gegenstände oder Ähnliches darstellen zu können, werden Bitmaps
verwendet. Sie enthalten die benötigten Informationen in Form eines Arrays,
bestehend aus Hexadezimalwerten.

Da das händische Erstellen aufwändig ist, wird an dieser Stelle empfohlen, ein
Programmen zum Erstellen von sogenannter „Pixel\sphinxhyphen{}Art“ zu verwenden. Das
hier verwendete Programm ist Aseprite (\sphinxurl{https://www.aseprite.org/}).
Eine kostenlose aber ebenso geeignete Variante stellt die Webanwendung Piskel
(\sphinxurl{https://www.piskelapp.com}) dar. Hier in schwarz und weiß erstellte Bilder
(schwarz als Hintergrund, weiß als das darzustellende Objekt) können als .png
Dateien exportiert werden. Diese können wiederherum von einem
Konvertierungstool in ein c++ Array umgewandelt werden. In diesem Projekt wurde
dafür ein selbstgeschriebenes Python\sphinxhyphen{}Skript verwendet (siehe Anhang 1).


\chapter{Vorbereiten der Hardware}
\label{\detokenize{hardware:vorbereiten-der-hardware}}\label{\detokenize{hardware::doc}}
Bevor mit der Programmierung begonnen werden kann, muss zunächst die Hardware
vorbereitet werden


\section{Benötigte Teile}
\label{\detokenize{hardware:benotigte-teile}}
Folgende Hardware wird vorausgesetzt:
\begin{itemize}
\item {} 
Ein Arduino Nano

\item {} 
Ein Steckbrett, dass von der Größe her mit dem Nano kompatibel ist

\item {} 
Einige Male\sphinxhyphen{}to\sphinxhyphen{}Male und Male\sphinxhyphen{}to\sphinxhyphen{}Female Steckkabel

\item {} 
Ein USB zu Mikro\sphinxhyphen{}USB Kabel

\item {} 
Ein Monochromes I2C\sphinxhyphen{}fähiges OLED\sphinxhyphen{}Display mit einer Auflösung von 128x64
Pixeln (Hier verwendet: \sphinxurl{https://www.amazon.de/dp/B01L9GC470/})

\item {} 
Ein Arduino Gamepad Shield (Hier verwendet: \sphinxurl{https://www.amazon.de/dp/B07CYZHRQT/})

\end{itemize}


\section{Aufbau}
\label{\detokenize{hardware:aufbau}}
Zuerst wird der Arduino Nano auf das Steckbrett gesteckt, sodass der Arduino
Nano auf der Lücke zwischen den Steckplatzreihen sitzt. Zu beiden Seiten sollten
zwei bis drei Steckplätze frei bleiben.

Folgende Verbindungen müssen nun hergestellt werden (siehe Schaubild):
\begin{itemize}
\item {} 
Arduino GND zu Display GND

\item {} 
Arduino 5V zu Display VCC

\item {} 
Arduino A4 zu Display SDA

\item {} 
Arduino A5 zu Display SCL

\item {} 
Arduino 5V zu +5V auf dem Gamepad

\item {} 
Arduino GND zu GND auf dem Gamepad

\item {} 
Arduino A1 zu Analog In 1 auf dem Gamepad

\item {} 
Arduino A0 zu Analog In 0 auf dem Gamepad

\item {} 
Arduino D7 zu 7 auf dem Gamepad

\item {} 
Arduino D6 zu 6 auf dem Gamepad

\item {} 
Arduino D5 zu 5 auf dem Gamepad

\item {} 
Arduino D4 zu 4 auf dem Gamepad

\item {} 
Arduino D3 zu 3 auf dem Gamepad

\item {} 
Arduino D2 zu 2 auf dem Gamepad

\end{itemize}

\noindent\sphinxincludegraphics[width=600\sphinxpxdimen]{{ArduinoDungeon_Steckplatine}.png}

Nun lässt sich über die Analogen Pins A0 und A1 der Zustand des Analog\sphinxhyphen{}Sticks
bestimmen. Die digitalen Pins 2 bis 7 erfassen welche Knöpfe gedrückt werden.
Ein LOW Signal bedeutet, dass der Knopf gedrückt wird, ein HIGH Signal, dass er
nicht gedrückt wird.


\chapter{Programmieren des Arduino}
\label{\detokenize{programming:programmieren-des-arduino}}\label{\detokenize{programming::doc}}
In diesem Kapitel wird die grobe Struktur des Programmes erläutert. Details
befinden sich in den Kommentaren des Quellcodes.


\section{Grobe Struktur}
\label{\detokenize{programming:grobe-struktur}}
\noindent\sphinxincludegraphics[width=700\sphinxpxdimen]{{pap}.png}

Zur besseren Übersicht sind im obigen Flussdiagramm die groben Strukturen der
drei wichtigsten Funktionen abgebildet.


\section{Verwendung der u8g2 Library}
\label{\detokenize{programming:verwendung-der-u8g2-library}}
Die u8g2 Library wird zum Ansteuern des OLED Displays verwendet. Dabei wird
sie zunächst zusammen mit der Wire Library eingebunden:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}U8g2lib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}Wire.h\PYGZgt{}}
\end{sphinxVerbatim}

Zudem wird ein Objekt erzeugt, über das die benötigten Methoden auferufen
werden. Die Klasse des Objektes ändert sich je nach verwendetem Display und
gewünschter Buffer Größe und kann der dem Display beiliegenden Anleitung
entnommen werden.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//U8G2\PYGZus{}SH1106\PYGZus{}128X64\PYGZus{}NONAME\PYGZus{}F\PYGZus{}HW\PYGZus{}I2C u8g2(U8G2\PYGZus{}R0, U8X8\PYGZus{}PIN\PYGZus{}NONE); // keep whole frame in buffer until cleared}
\PYG{c+c1}{//U8G2\PYGZus{}SH1106\PYGZus{}128X64\PYGZus{}NONAME\PYGZus{}1\PYGZus{}HW\PYGZus{}I2C u8g2(U8G2\PYGZus{}R0, U8X8\PYGZus{}PIN\PYGZus{}NONE); // keep only one page in buffer}
\PYG{n}{U8G2\PYGZus{}SH1106\PYGZus{}128X64\PYGZus{}NONAME\PYGZus{}2\PYGZus{}HW\PYGZus{}I2C} \PYG{n+nf}{u8g2}\PYG{p}{(}\PYG{n}{U8G2\PYGZus{}R0}\PYG{p}{,} \PYG{n}{U8X8\PYGZus{}PIN\PYGZus{}NONE}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// keep two pages in buffer}
\end{sphinxVerbatim}

In diesem Projekt wird als Kompromiss zwischen Performanz und RAM\sphinxhyphen{}Verbrauch
die Klasse für den two\sphinxhyphen{}page\sphinxhyphen{}buffer verwendet.


\subsection{Buffer und pages}
\label{\detokenize{programming:buffer-und-pages}}
Um das Display effizient ansteuern zu können, muss
ein Abbild der einzelnen Pixel des Displays im RAM des Arduinos gespeichert
werden. Dies ist der Display Buffer. Wenn nun etwas dargestellt werden soll,
wird dieser Buffer an das Display gesendet, wo der Controller diesen Buffer
auswertet. Der Nachteil dieser Methode ist, dass 128*64 bit, also ungefähr ein
Kilobyte RAM dafür benötigt werden. Das ist bereits die Hälfte des zur
Verfügung stehenden Speichers, wenn man alle anderen von der Library
verwendeten Objekte und Variablen außer Acht lässt. Insgesamt wird so ohne
weiteren selbst geschriebenen Code ungefähr 80\% des RAMs belegt.

Die hier verwendete Alternative basiert darauf, dass der Buffer in acht pages
eingeteilt wird und jeweils nur ein bzw. zwei pages auf einmal im
Arbeitsspeicher gehalten werden. Dies hat zwar den Nachteil, dass acht bzw.
vier Signale für jedes Erneuern des Displays versendet werden müssen, der
Zeitverlust ist für diesen Anwendungsfall aber glücklicherweise
vernachlässigbar.


\subsection{Verwendete Methoden}
\label{\detokenize{programming:verwendete-methoden}}
Die in diesem Projekt verwendeten Methoden sind:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{firstPage()}} und \sphinxcode{\sphinxupquote{nextPage()}}: Werden zum Senden des Buffers verwendet

\item {} 
\sphinxcode{\sphinxupquote{setFont()}}: Bestimmt die Schriftart der darzustellenden Texte. Die
Schriftart bestimmt auch die Schriftgröße

\item {} 
\sphinxcode{\sphinxupquote{drawStr()}}: Zeichnet einen Text an den angegebenen Koordinaten.

\item {} 
\sphinxcode{\sphinxupquote{drawDisc()}}: Zeichnet einen ausgefüllten Kreis an den angegebenen
Koordinaten

\item {} 
\sphinxcode{\sphinxupquote{drawCircle()}}: Zeichnet einen leeren Kreis an den angegebenen Koordinaten

\item {} 
\sphinxcode{\sphinxupquote{drawBox()}}: Zeichnet eine Box an den angegebenen Koordinaten

\item {} 
\sphinxcode{\sphinxupquote{drawFrame()}}: Zeichnet einen Rahmen an den angegebenen Koordinaten

\item {} 
\sphinxcode{\sphinxupquote{drawHLine()}}: Zeichnet eine Horizontale Linie an den angegebenen
Koordinaten und mit der angegebenen Länge.

\item {} 
\sphinxcode{\sphinxupquote{drawXBM()}}: Zeichnet ein Bild an den angegebenen Koordinaten. Als Argument
wird eine Bitmap erwartet.

\item {} 
\sphinxcode{\sphinxupquote{setDrawColor()}}: Legt fest, wie gezeichnet werden soll. Wird eine 0
übergeben, werden Pixel durch \sphinxcode{\sphinxupquote{draw}} Funktionen aus\sphinxhyphen{} statt eingeschaltet.
1 ist der Standardwert.

\end{itemize}

Alle zur Verfügung stehenden Methoden können ebenfalls im offiziellen
Repository auf Github eingesehen werden: \sphinxurl{https://github.com/olikraus/u8g2/wiki/u8g2reference}


\subsection{Konkreter Anwendungsfall}
\label{\detokenize{programming:konkreter-anwendungsfall}}
Ein Beispiel aus dem Code dieses Projektes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{u8g2}\PYG{p}{.}\PYG{n}{firstPage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{do} \PYG{p}{\PYGZob{}}
    \PYG{n}{u8g2}\PYG{p}{.}\PYG{n}{setFont}\PYG{p}{(}\PYG{n}{u8g2\PYGZus{}font\PYGZus{}tenfatguys\PYGZus{}t\PYGZus{}all}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u8g2}\PYG{p}{.}\PYG{n}{drawStr}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{How To Play}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{//[...]}

  \PYG{p}{\PYGZcb{}} \PYG{k}{while} \PYG{p}{(}\PYG{n}{u8g2}\PYG{p}{.}\PYG{n}{nextPage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Mit dem Aufruf der Methode \sphinxcode{\sphinxupquote{firstPage}} wird sichergestellt, dass mit dem
Übertragen der ersten page begonnen wird. Lässt man dies weg, wird unter
Umständen nur die letzte page bzw. die letzten beiden pages übertragen.
Der Aufruf der Methode \sphinxcode{\sphinxupquote{nextPage}} bereitet das Übertragen der nächsten
(beiden) page(s) vor und gibt false zurück, wenn es keine weitere zu
übertragende page gibt.

Mit \sphinxcode{\sphinxupquote{setFont}} wird eine Schriftart ausgewählt, die in diesem Fall neun Pixel
hoch ist.

Mit \sphinxcode{\sphinxupquote{drawStr}} wird der Text „How To Play“ an den Koordinaten (8|15)
dargestellt. Das Koordinatensystem hat oben links den Nullpunkt, die
Koordinaten geben die Position der unteren linken Ecke des Textes an.


\subsection{Bitmaps}
\label{\detokenize{programming:bitmaps}}
Die Bitmaps für Objekte und Akteure werden als unsigned char Arrays
gespeichert. Dabei steht jeder hexadezimale char für einen Byte in binär
(\sphinxcode{\sphinxupquote{0x2e}} z.B. entspricht \sphinxcode{\sphinxupquote{00101110}}) der wiederherum eine Zeile des
darzustellenden Bildes beschreibt. Jede Eins steht für einen „eingeschalteten“
Pixel, jede Null für einen „ausgeschalteten“. Das Bit mit dem niedrigsten
Stellenwert wird links dargestellt, darauf folgende Bits werden rechts davon
angereiht.

So wird aus \sphinxcode{\sphinxupquote{\{0x00, 0x3e, 0x5b, 0x7f, 0x2b, 0x03, 0x56, 0x7c\}}} folgendes
Bild:

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{skull}.png}

Anzumerken ist an dieser Stelle noch, dass für dieses Projekt alle Sprites
(sprich: Bilder für Wände und Akteure) die obere Reihe und die rechte Spalte
der Bitmap ungenutzt lassen, um einen visuellen Unterschied zwischen
benachbarten Akteuren zu schaffen.

Bitmaps werden auch dafür verwendet die Positionen der Wände zu definieren.
Siehe dazu Abschnitt „Die Funktion draw()“


\section{Eigene Funktionen und Strukturen}
\label{\detokenize{programming:eigene-funktionen-und-strukturen}}

\subsection{Die Funktion isWall()}
\label{\detokenize{programming:die-funktion-iswall}}
Diese Funktion gibt zurück, ob an einer angegebenen Position eine Wand steht.


\subsubsection{Parameter}
\label{\detokenize{programming:parameter}}
Diese Funktionen erwarten keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:funktionsweise}}
Vom aktuellen Level wird mit \sphinxcode{\sphinxupquote{getWalls(){[}x{]}}} die Spalte passend zur
X\sphinxhyphen{}Koordinate genommen. Dieser Byte wird um die y\sphinxhyphen{}Koordinate geshiftet und mit
der binären 1 verundet. Das Ergebnis wird zurückgegeben.


\subsection{Die Funktion getWalls()}
\label{\detokenize{programming:die-funktion-getwalls}}
Diese Funktion gibt die Wand\sphinxhyphen{}Bitmap für das aktuelle Level zurück.


\subsubsection{Parameter}
\label{\detokenize{programming:id1}}
Diese Funktionen erwarten keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id2}}
Mit einem einfachen switch/case Statement wird die passende Bitmap zum
aktuellen Level bestimmt und zurückgegeben.


\subsection{Die Funktion getButtonPress()}
\label{\detokenize{programming:die-funktion-getbuttonpress}}
Diese Funktion gibt zurück, ob ein angegebener Button gedrückt bzw. der
Joystick in eine bestimmte Richtung bewegt wird.


\subsubsection{Parameter}
\label{\detokenize{programming:id3}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int button}}: Die ID eines Buttons/einer Joystick\sphinxhyphen{}Richtung. Statt Zahlen zu
übergeben sollten für die Lesbarkeit die Aliase verwendet werden, die zu
Beginn der Projektdatei definiert wurden:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define BTN\PYGZus{}UP        1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define BTN\PYGZus{}DOWN      2}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define BTN\PYGZus{}LEFT      3}
\PYG{c+c1}{//[...]}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id4}}
Durch ein switch statement wird eine Fallunterscheidung bezüglich der
verschiedenen Buttons/Richtungen des Joysticks vorgenommen. Hierbei ist zu
beachten, dass für Buttons ein \sphinxcode{\sphinxupquote{digitalRead(Pin)}} \sphinxcode{\sphinxupquote{true}} zurückgibt, wenn
der Button \sphinxstyleemphasis{nicht} gedrückt wird.

Die Zustände der beiden Achsen des Joysticks
werden über zwei analoge Pins abgefragt, die einen Wert von 0 bis 1023
zurückgeben. Ein Wert von \textasciitilde{}512 bedeutet hierbei, dass der Joystick auf dieser
Achse nicht bewegt wird. Für die Nutzerfreundlichkeit werden leichte Bewegungen
des Joysticks (\sphinxcode{\sphinxupquote{analogRead(Pin)}} gibt einen Wert größer als 800 oder
kleiner als 200 zurück) nicht berücksichtigt.

Für die Richtungen, in die der Joystick gedrückt werden kann, wird zudem
berücksichtigt, dass kein Drücken in eine andere Richtung erfolgen darf. So
wird vermieden, dass sich der Spieler diagonal bewegt.

Der Spezialfall \sphinxcode{\sphinxupquote{BTN\_ANY}} gibt zurück, ob der Inventar\sphinxhyphen{}, Angriff\sphinxhyphen{} oder
Ruhe\sphinxhyphen{}Knopf gedrückt wird.


\subsection{Die Funktion draw()}
\label{\detokenize{programming:die-funktion-draw}}
Diese Funktionen wird mit jedem Durchlauf von \sphinxcode{\sphinxupquote{loop()}} ausgeführt. Sie
verwendet die u8g2 Library um den aktuellen Zustand des Levels auf dem Display
darzustellen.


\subsubsection{Parameter}
\label{\detokenize{programming:id5}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id6}}
Der gesamte Inhalt der Funktion wird von dem im Abschnitt „Verwendung der u8g2
Library“ beschriebenen do while Loop eingeschlossen, der nach und nach alle
pages an das Display überträgt.

In dem Loop werden zuerst die Wände des aktuellen Levels gezeichnet. Dies hat
den Vorteil, dass fehlpositionierte Akteure oder Spieler Charaktere nicht
überdeckt werden, was das Debugging vereinfacht. Dazu wird über die Bitmap des
aktuellen Levels, die durch \sphinxcode{\sphinxupquote{getWalls()}} zur Verfügung steht, iteriert. Das
Vorgehen ist dabei das folgende:

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{level}.png}

Jeder Byte (char) stellt eine Spalte des aktuellen Levels dar. Das erste Bit
repräsentiert dabei die Y\sphinxhyphen{}Koordinate 0, das zweite die Y\sphinxhyphen{}Koordinate 1
usw. Durch das Nutzen eines bitweisen UNDs mit dem 1\sphinxhyphen{}char (0x01) kann
ausgelesen werden, ob das erste Bit eine 0 oder eine 1 enthält; entsprechend
wird an dieser Stelle eine Wand gezeichnet. Dann wird mit einem Bitshift nach
rechts das zweite Bit an die Position des ersten geschoben und erneut
ausgewertet. Nach sieben Bitshifts ist die gesamte Spalte ausgelesen und die
nächste kann betrachtet werden.

Im Anschluss an das Zeichnen der Wände wird die Position des Spielers
ausgelesen und an der entsprechenen Stelle dargestellt. Durch einen Loop über
das Array \sphinxcode{\sphinxupquote{actors}} geschieht das gleiche mit jedem anderen Akteur.

Zum Schluss wird die GUI gezeichnet. Dafür wird mit einer horizontale Linie
der Spielbereich abgetrennt, und durch Symbole die aktuellen Lebenspunkte und
Leben dargestellt. Zwei loops zeichnen dafür in festen Abständen Kreise bzw.
Herzen.


\subsection{Die Funktionen showStartScreen() und showHelpScreen()}
\label{\detokenize{programming:die-funktionen-showstartscreen-und-showhelpscreen}}
Diese Funktionen werden zu Beginn des Spieles verwendet. Sie zeigen den
Startbildschirm und direkt danach eine kurze Erklärung der Steuerung.


\subsubsection{Parameter}
\label{\detokenize{programming:id7}}
Diese Funktionen erwarten keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id8}}
Beide Funktionen beinhalten eine Schleife für das wiederholte Darstellen der
jeweiligen Informationen. Dabei wird für den Startbildschirm mit jedem
Durchlauf der Schleife die Y\sphinxhyphen{}Position des Titels angepasst, sodass ein
„schwebender“ visueller Effekt erzielt wird. Der von der Funktion
\sphinxcode{\sphinxupquote{showHelpScreen()}} erzeugt Hilfe\sphinxhyphen{}Bildschirm enthält blinkenden Text. Dies
wird dadurch realisiert, dass nicht bei jedem Durchlauf der Schleife der Text
angezeigt wird.


\subsection{Die Funktion showDeathScreen()}
\label{\detokenize{programming:die-funktion-showdeathscreen}}
Diese Funktion wird aufgerufen, wenn der Spieler gestorben ist. Sie
informiert den Spieler über seinen Tod.


\subsubsection{Parameter}
\label{\detokenize{programming:id9}}
Es wird erwartet, dass eine boolscher Wertes übergeben wird, der anzeigt,
ob der Spieler alle Leben verbraucht hat.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id10}}
Die Funktion zeichnet die Wände des aktuellen Levels (siehe \sphinxcode{\sphinxupquote{draw()}}) und
darüber einen Rahmen mit der Nachricht „YOU DIED“.

Sollte der Spieler sein letztes Leben verloren haben, so wird stattdessen
„GAME OVER“ angezeigt und eine Animation abgespielt. Zudem werden die Werte des
Spielers (Leben, Rüstung etc.) zurückgesetzt.


\subsection{Die Funktion showEndScreen()}
\label{\detokenize{programming:die-funktion-showendscreen}}
Diese Funktion wird aufgerufen, wenn der Spieler Level 4 erreicht. Sie zeichnet
den End Screen.


\subsubsection{Parameter}
\label{\detokenize{programming:id11}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id12}}
Die Funktion setzt anfangs alle Werte des Spielers zurück, damit nach Beenden
des Spieles erneut gespielt werden kann.

Im Anschluss werden Texte, die den Spieler beglückwünschen, angezeigt.

Drückt der Spieler einen Knopf, so werden \sphinxcode{\sphinxupquote{showStartScreen()}},
\sphinxcode{\sphinxupquote{showHelpScreen()}} und \sphinxcode{\sphinxupquote{setUpLevel()}} aufgerufen, und das Spiel beginnt von
vorn.


\subsection{Die Funktion loop()}
\label{\detokenize{programming:die-funktion-loop}}
Diese Funktionen wird wiederholt ausgeführt, bis der Arduino abgeschaltet wird.

Sie ist bereits beim Erstellen eines Arduino Projektes vorhanden.


\subsubsection{Parameter}
\label{\detokenize{programming:id13}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id14}}
Zu Beginn jedes Durchlaufes wird darauf gewartet, dass der Spieler eine gültige
Eingabe tätigt. Dazu läuft eine while\sphinxhyphen{}Schleife ohne Inhalt solange durch,
bis die Funktion \sphinxcode{\sphinxupquote{playerAct()}} true zurückgibt. Ist dies geschehen, so wird
für jeden Actor die Methode \sphinxcode{\sphinxupquote{act()}} aufgerufen. Dies sorgt insgesamt dafür,
dass Akteure nur dann agieren, wenn auch der Spieler agiert hat. So wird der
Effekt einer rundenbasierten Spielweise erzielt, bei der der Spieler Zeit zum
Planen hat.

Im Anschluss wird mit dem Aufruf der Funktion \sphinxcode{\sphinxupquote{draw()}} der Momentane Zustand
der Akteure und des Spielers auf dem Display dargestellt.

Durch ein \sphinxcode{\sphinxupquote{delay(200)}} wird der nächste Aufruf von \sphinxcode{\sphinxupquote{loop()}} verzögert,
damit ein Gedrückthalten des Joysticks den Spieler Charakter nicht
unkontrollierbar in eine Richtung bewegt.


\subsection{Die Funktion setup()}
\label{\detokenize{programming:die-funktion-setup}}
Diese Funktionen wird zu Beginn der Ausführung des Programmes ein einziges Mal
aufgerufen. Sie ist dafür gedacht, benötigte Libraries, Objekte und Ähnliches
vorzubereiten.

Sie ist bereits beim Erstellen eines Arduino Projektes vorhanden.


\subsubsection{Parameter}
\label{\detokenize{programming:id15}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id16}}
Zu Beginn wird der Zufallsgenerator des Arduino initialisiert und ein Seed
vergeben. Dies bewirkt, dass für jede Programmausführung die selbe Folge
„zufälliger“ Zahlen generiert wird. Dies ist für das Debugging von
Akteur\sphinxhyphen{}Verhalten hilfreich.

Im Anschluss wird das Objekt u8g2 initialisiert. Es wird für die Kommunikation
mit dem Display gebraucht.

Nach dem Initialisieren werden die Funktionen zur Darstellung vom
Startbildschirm und zum Anzeigen der Steuerung aufgerufen. Hat der Benutzer
beide bestätigt, wird das erste Level als momentanes Level gesetzt und
\sphinxcode{\sphinxupquote{setUpLevel()}} aufgerufen, um das erste Level zu initialisieren.

Zum Schluss wird \sphinxcode{\sphinxupquote{draw()}} aufgerufen um die Wände und Akteure anzuzeigen.


\subsection{Die Funktion setUpLevel()}
\label{\detokenize{programming:die-funktion-setuplevel}}
Initialisiert das aktuelle Level.


\subsubsection{Parameter}
\label{\detokenize{programming:id17}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id18}}
Zu Beginn wird player\_haskey zurückgesetzt, damit der Spieler nach einem Tod
den Schlüssel nicht behält. Danach werden in einem großen switch/case\sphinxhyphen{}Statement
für jedes Level die Akteure und die Spielerposition gesetzt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{case} \PYG{l+m+mi}{3}\PYG{o}{:}
\PYG{n}{player\PYGZus{}posx} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{player\PYGZus{}posy} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{n}{actors}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// key}
\PYG{n}{actors}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{setup}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// door}
\end{sphinxVerbatim}

Hat das momentane Level die ID 4, wird stattdessen der End Screen gezeigt.


\subsection{Die Funktion playerAct()}
\label{\detokenize{programming:die-funktion-playeract}}
Diese Funktionen dient dem Verarbeiten des Spieler\sphinxhyphen{}Inputs. Sie gibt true oder
false zurück, je nachdem ob der Spieler eine Aktion erfolgreich durchgeführt
hat oder nicht.


\subsubsection{Parameter}
\label{\detokenize{programming:id19}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id20}}
Die Hauptstruktur der Funktion besteht aus mehreren if\sphinxhyphen{}else\sphinxhyphen{}Blöcken, die die
möglichen Tastendrücke/Joystickbewegungen des Spielers abfragen.

Für Bewegungen des Joysticks wird abgefragt, ob an der Zielkoordinate des
Spielers eine Wand vorhanden ist. Ist dem nicht so, wird die Position des
Spielers angepasst.

Drückt der Spieler den „ATTACK“\sphinxhyphen{}Button, so wird der Rückgabewert der Funktion
\sphinxcode{\sphinxupquote{playerAttack()}} zurückgegeben.

Drückt der Spieler den „INVENTORY“\sphinxhyphen{}Button, so wird das Inventar des Spieler
mithilfe der Funktion \sphinxcode{\sphinxupquote{playerOpenInventory()}} geöffnet.

Drückt der Spieler den „REST“\sphinxhyphen{}Button, so wird kein zusätzlicher Code
ausgeführt, damit der Spieler eine Möglichkeit hat, seinen „Zug“ zu
überspringen.


\subsection{Die Funktion playerAttack()}
\label{\detokenize{programming:die-funktion-playerattack}}
Diese Funktion wird ausgeführt, wenn der Spieler angreift. Befinden sich Gegner
neben dem Spieler, erleiden sie Schaden.


\subsubsection{Parameter}
\label{\detokenize{programming:id21}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id22}}
Es wird über alle Akteure iteriert um
zu prüfen, welche (initialisierten) Akteure neben dem Spieler stehen. Steht ein
Akteur neben dem Spieler, so wird die Methoed \sphinxcode{\sphinxupquote{takeDamage()}} des Akteurs
aufgerufen und die aktuelle Waffe des Spielers \sphinxcode{\sphinxupquote{player\_weapon}} übergeben.
Zudem wird die Methode \sphinxcode{\sphinxupquote{blink()}} aufgerufen, die einen Akteur blinken lässt.
Sollte der Angriff allerdings
keinen Akteur treffen, so wird in einer gesonderten Überprüfung false
zurückgegeben.

Die aktuelle Waffe des Spielers ist ein integer, der über ein \sphinxcode{\sphinxupquote{\#define}}
eingestanzt wird:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define WPN\PYGZus{}HANDS 1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define WPN\PYGZus{}SWORD 3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define WPN\PYGZus{}MAGIC 5}
\PYG{c+c1}{//[...]}
\end{sphinxVerbatim}
\end{quote}


\subsection{Die Funktion damagePlayer()}
\label{\detokenize{programming:die-funktion-damageplayer}}
Diese Funktion wird ausgeführt, wenn der Spieler angegriffen wird. Sie zieht
Leben ab und ruft ggf. \sphinxcode{\sphinxupquote{showDeathScreen()}} auf.


\subsubsection{Parameter}
\label{\detokenize{programming:id23}}
Diese Funktion erwartet den vom Gegner verursachten Schaden.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id24}}
Der Rüstwert des Spielers wird vom zu verursachende Schaden abgezogen und dem
Spieler vom Leben abgezogen. Sinkt das Leben auf oder unter 0, so verliert der
Spieler ein Leben und der Death Screen wird angezeigt. Nach einem delay wird
das momentane Level erneut mit setUpLevel aufgebaut.


\subsection{Die Funktion playerOpenInvenory()}
\label{\detokenize{programming:die-funktion-playeropeninvenory}}
Diese Funktion wird ausgeführt, wenn der Spieler das Inventar öffnet.


\subsubsection{Parameter}
\label{\detokenize{programming:id25}}
Diese Funktion erwartet keine Parameter.


\subsubsection{Funktionsweise}
\label{\detokenize{programming:id26}}
Zu Beginn der Funktion werden die Wände des aktuellen Levels gezeichnet
(siehe \sphinxcode{\sphinxupquote{draw()}}). Im Anschluss wird eine Box mit Rahmen dargestellt, in der
je nach aktuellem Wert von \sphinxcode{\sphinxupquote{player\_weapon}} und \sphinxcode{\sphinxupquote{player\_armour}} die Rüstung
und Waffe des Spielers als Text und als Bitmap gezeichnet werden.

Besitzt der Spieler einen Schlüssel, so wird zudem ein Schlüssel in der Ecke
des Inventars angezeigt.


\subsection{Globale Variablen}
\label{\detokenize{programming:globale-variablen}}
Es werden mehrere globale Variablen verwendet, auf die alle Funktionen und
Methoden zugriff haben.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Variable
&
Verwendung
\\
\hline
Actor actors{[}{]}
&
Enthält alle Akteure
des aktuellen
Levels.

Akteure des Typen 0
gelten als nicht
initialisiert und

werden bei den
meisten Abfragen
ignoriert.
\\
\hline
uint8\_t cur\_level
&
Enthält die Nummer
des aktuellen
Levels.
\\
\hline
static unsigend char
level\_level\textless{}x\textgreater{}{[}{]}
&
Enthält die Bitmap
für die Wände des
x\sphinxhyphen{}ten Levels.
\\
\hline
static unsigned char
sprite\_\textless{}x\textgreater{}{[}{]}
&
Ehtält die Bitmap
für den Actor mit
dem Namen x
\\
\hline
uint8\_t player\_posx

uint8\_t player\_posy

uint8\_t player\_weapon

uint8\_t player\_armour

uint8\_t player\_health

uint8\_t player\_lives

bool player\_haskey
&
Enthalten die
Koordinaten und
andere Spieler\sphinxhyphen{}Werte:

Rüstung
und Waffe werden als
Zahl gespeichert,

die zugleich ID und
Schaden/Rüstwert
ist. Leben und

Lebenspunkte werden
ebenfalls gespeichert,

sowie ob der Spieler
einen Schlüssel
gefunden hat.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Die Klasse/Struktur actor}
\label{\detokenize{programming:die-klasse-struktur-actor}}
Objekte dieser Klasse speichern Informationen zu den verschieden Akteuren in
einem Level wie etwa Items und Gegner.


\subsubsection{Felder}
\label{\detokenize{programming:felder}}
Es werden mehrere Felder verwendet um Informationen zu einzelnen Instanzen
dieser Klasse zu speichern.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

Feld
&
Verwendung
\\
\hline
uint8\_t health
&
Entspricht
dem verbleibenden
Leben des Gegners.
\\
\hline
uint8\_t damage
&
Entspricht
dem Schaden, den der
Gegner verursacht
\\
\hline
uint8\_t type

uint8\_t subtype
&
Bestimmt das
Verhalten und das
Aussehen des Actors.
\\
\hline
uint8\_t cur\_x

uint8\_t cur\_y
&
Die momentanen
Koordinaten des
Actors.
\\
\hline
uint8\_t old\_x

uint8\_t old\_y
&
Die Koordinaten des
Actors im
vorangegangenen Zug.
Wird verwended,

um
das Verhalten besser
steuern zu können.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Die Methode actor.setup()}
\label{\detokenize{programming:die-methode-actor-setup}}
Diese Funktion erleichtert das Initialisieren eines Actors, da alle wichtigen
Felder auf einmal gesetzt werden können.

\sphinxstylestrong{Paramter}

Folgende Parameter werden erwartet:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{uint8\_t x}}: X\sphinxhyphen{}Koordinate des Akteurs

\item {} 
\sphinxcode{\sphinxupquote{uint8\_t y}}: Y\sphinxhyphen{}Koordinate des Akteurs

\item {} 
\sphinxcode{\sphinxupquote{uint8\_t type}}: Typ des Akteurs

\item {} 
\sphinxcode{\sphinxupquote{uint8\_t subtype}}: Untertyp des Akteurs, standardmäßig 0

\end{itemize}

\sphinxstylestrong{Funktionsweise}

Setzt die entsprechenden Felder auf die übergebenen Werte. Das Feld \sphinxcode{\sphinxupquote{health}}
wird je nach Typ anders gesetzt.


\subsubsection{Die Funktion getSprite()}
\label{\detokenize{programming:die-funktion-getsprite}}
Diese Funktionen gibt die passende Bitmap zu dem übergeben Akteur zurück.

\sphinxstylestrong{Parameter}

Es werden keine Parameter erwartet.

\sphinxstylestrong{Funktionsweise}

Durch ein simples switch\sphinxhyphen{}case Statement wird je nach Typ des Akteurs die
passende Bitmap zurückgegeben. Sollte kein case zutreffen, wird eine spezielle
Bitmap zurückgegeben, die signalisiert, dass keine passende Textur zu dem Typen
existiert.

\noindent\sphinxincludegraphics[width=100\sphinxpxdimen]{{nosprite}.png}


\subsubsection{Die Methode actor.takeDamage()}
\label{\detokenize{programming:die-methode-actor-takedamage}}
Diese Funktion berechnet das Leben des Actors nach einem Angriff des Spielers

\sphinxstylestrong{Paramter}
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int damage}}: Der zu erleidende Schaden

\end{itemize}

\sphinxstylestrong{Funktionsweise}

\sphinxcode{\sphinxupquote{damage}} wird von \sphinxcode{\sphinxupquote{health}} abgezogen. Sollte dies einen negativen Wert oder
0  ergeben, so wird der Typ des Actors auf 0 gesetzt. Ruft zudem \sphinxcode{\sphinxupquote{blink()}}
auf, und \sphinxcode{\sphinxupquote{draw()}}, falls der Akteur keine Lebenspunkte mehr hat. Letzteres
ist wichtig, da bei einem Neuzeichnen des Spielfeldes der Gegner sofort
statt erst im nächsten Zug verschwindet.


\subsubsection{Die Methode blink()}
\label{\detokenize{programming:die-methode-blink}}
Diese Funktionen lässt den Akteur blinken.

\sphinxstylestrong{Parameter}

Es werden keine Parameter erwartet.

\sphinxstylestrong{Funktionsweise}

In einer for\sphinxhyphen{}Schleife wird der Typ des Akteurs wiederholt auf 0 und zurück auf
den originalen Typen gesetzt. Da bei jedem Wechsel die \sphinxcode{\sphinxupquote{draw()}} Funktion
aufgerufen wird, die Akteure vom Typen 0 nicht zeichnet, entsteht ein
blinkender Effekt.


\subsubsection{Die Methode actor.setPosition()}
\label{\detokenize{programming:die-methode-actor-setposition}}
Diese Funktion setzt die absolute Position eines Actors.

\sphinxstylestrong{Paramter}

Folgende Parameter werden erwartet:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{uint8\_t new\_x}}: Die neue X\sphinxhyphen{}Koordinate

\item {} 
\sphinxcode{\sphinxupquote{uint8\_t new\_y}}: Die neue Y\sphinxhyphen{}Koordinate

\end{itemize}

\sphinxstylestrong{Funktionsweise}

\sphinxcode{\sphinxupquote{cur\_x, cur\_y, old\_x, old\_y}} werden entsprechend der übergebenen Werte neu
gesetzt.


\subsubsection{Die Methode actor.move()}
\label{\detokenize{programming:die-methode-actor-move}}
Diese Funktion setzt die Position eines Actors relativ zur momentanen Position.

\sphinxstylestrong{Paramter}

Folgende Parameter werden erwartet:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{int8\_t x\_offset}}: Der Wert, um die der Akteur auf der X\sphinxhyphen{}Achse verschoben
werden soll

\item {} 
\sphinxcode{\sphinxupquote{int8\_t y\_offset}}: Der Wert, um die der Akteur auf der Y\sphinxhyphen{}Achse verschoben
werden soll

\end{itemize}

\sphinxstylestrong{Funktionsweise}

\sphinxcode{\sphinxupquote{cur\_x, cur\_y, old\_x, old\_y}} werden entsprechend der übergebenen Werte neu
gesetzt, wenn sich keine Wand an der neuen Position befindet. Kann sich der
Akteur an die neue Position bewegen, so wird true zurückgegeben, andernfalls
false.


\subsubsection{Die Methoden actor.moveLeft(), actor.moveRight(), actor.moveAhead(), actor.moveBack()}
\label{\detokenize{programming:die-methoden-actor-moveleft-actor-moveright-actor-moveahead-actor-moveback}}
Diese Funktionen sind Kurzschreibweisen von \sphinxcode{\sphinxupquote{actor.move()}}. Die
Richtungsanweisungen sind relativ zur momentanen Bewegungsrichtung.

\sphinxstylestrong{Paramter}

Es werden keine Parameter erwartet.

\sphinxstylestrong{Funktionsweise}

Ruft die Methode \sphinxcode{\sphinxupquote{actor.move()}} auf. Dabei werden die momentane und die
vorherige Position so übergeben, dass sich die Richtung (z.B. „Ahead“) auf die
aktuelle Bewegungsrichtung bezieht. Das Bedeutet, dass ein \sphinxcode{\sphinxupquote{actor.moveAhead()}}
den Actor ein Feld nach oben versetzt, wenn sein vorherige Position ein Feld
unter der aktuellen liegt.


\subsubsection{Die Methoden actor.wallLeft(), actor.wallRight(), actor.wallAhead()}
\label{\detokenize{programming:die-methoden-actor-wallleft-actor-wallright-actor-wallahead}}
Diese Funktionen sind Kurzschreibweisen von \sphinxcode{\sphinxupquote{isWall()}}. Die
Richtungsanweisungen sind relativ zur momentanen Bewegungsrichtung.

\sphinxstylestrong{Paramter}

Es werden keine Parameter erwartet.

\sphinxstylestrong{Funktionsweise}

Es wird zurückgegeben ob sich in der entsprechenden Richtung eine Wand
befindet. So returniert \sphinxcode{\sphinxupquote{actor.wallLeft()}} true, wenn links des Actors eine
Wand ist. Bestimmt wird dies mithilfe der Funktion \sphinxcode{\sphinxupquote{isWall()}}. So wie bei den
Methoden \sphinxcode{\sphinxupquote{actor.moveX()}} sind die Richtungen relativ zur momentanen
Bewegungsrichtung zu verstehen.


\subsubsection{Die Methode actor.act()}
\label{\detokenize{programming:die-methode-actor-act}}
Diese Funktionen wird nach jeder erfolgreichen Aktion des Spielers aufgerufen
und dafür genutzt, Verhalten von Actors festzulegen. So wird hier zum Beispiel
das Bewegungsmuster des Skull\sphinxhyphen{}Gegners definiert.

\sphinxstylestrong{Paramter}

Es werden keine Parameter erwartet.

\sphinxstylestrong{Funktionsweise}

Zu Beginn wird der Typ des Actors abgefragt. Ist dieser vom Typ vier, also dem
Skull\sphinxhyphen{}Gegner, so wird eine Fallunterscheidung vorgenommen:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
Befindet sich der Spieler ein Feld neben dem Akteur, so wird
\sphinxcode{\sphinxupquote{damagePlayer()}} aufgerufen.

\item {} 
Ist das nicht der Fall und ist die aktuelle Position gleich der vorherigen
Position, so wird im
Uhrzeigersinn von Rechts ausgehend versucht, ein Feld voranzuschreiten.
Dies geschieht unter Verwendung der \sphinxcode{\sphinxupquote{move()}} Methode, da \sphinxcode{\sphinxupquote{moveRight()}}
und Ähnliches ohne eine vorherige Position nicht funktioniert.

\item {} 
Ist keiner der obrigen Fälle eingetreten, so bewegt sich der Skull\sphinxhyphen{}Gegner
nach folgendem Muster:
\begin{itemize}
\item {} 
Sind zwei Wände vor oder seitlich vom Gegner, bewegt er sich in die
verbleibende Richtung. Sollte das nicht möglich sein, dreht er um.

Beispiel: Links und vor dem Gegner ist eine Wand. Er versucht sich nach
rechts zu bewegen. Schlägt das fehl, geht er einen Schritt zurück.

\item {} 
Ist eine Wand vor oder seitlich vom Gegner, wählt er per Zufall eine der
beiden Richtungen aus und bewegt sich dorthin.

\item {} 
Ist keine Wand vor oder seitlich vom Gegner, wählt er per Zufall eine der
Richtungen aus und bewegt sich dorthin.

\item {} 
Es muss nicht berücksichtigt werden, ob sich hinter dem Gegner eine Wand
befindet, da er aus dieser Richtung kommt. Ist er von Wänden umgeben,
greift Abfrage 2)

\end{itemize}

\end{enumerate}

Ist der Akteur vom Typ zwei, also ein Schlüssel, so wird geprüft, ob sich
der Spieler an der aktuellen Position des Schlüssels befindet. Ist das der
Fall, so wird der Typ des Akteurs auf 0 gesetzt und \sphinxcode{\sphinxupquote{player\_haskey}} auf true.

Ist der Akteur vom Typ drei, also eine Tür, so wird geprüft, ob sich der
Spieler an der aktuellen Position der Tür befindet und einen Schlüssel hat. Ist
das der Fall, so wird \sphinxcode{\sphinxupquote{player\_haskey}} auf false gesetzt, \sphinxcode{\sphinxupquote{cur\_level}}
inkrementiert und \sphinxcode{\sphinxupquote{setUpLevel()}} aufgerufen.

Ist der Akteur vom Typ 6, also ein Geister\sphinxhyphen{}Gegner, so wird eine
Fallunterscheidung vorgenommen:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
Befindet sich der Spieler ein Feld neben dem Akteur, so wird
\sphinxcode{\sphinxupquote{damagePlayer()}} aufgerufen.

\item {} 
Ist das nicht der Fall und ist die aktuelle Position gleich der vorherigen
Position, so wird nach \sphinxcode{\sphinxupquote{subtype}} unterschieden. Subtyp 1 bewegt sich nach
unten, subtyp 0 nach oben. Dies legt die Startrichtung der Geister fest,
die um einen Bereich kreisen sollen.

\item {} 
Ist keiner der obrigen Fälle eingetreten, so wird geprüft, ob sich der Geister
nach vorne bewegen kann, ansonsten biegt er nach links ab.

\end{enumerate}

Insgesamt entsteht so für die Geister eine Kreisbewegung um eine freie Fläche
in der Mitte.

Ist der Akteur vom Typ 5, 7, 8 oder 9, also ein Ausrüstungsgegenstand, so wird
geprüft, ob sich der Spieler an der aktuellen Position des Akteurs befindet.
Ist das der Fall, wird \sphinxcode{\sphinxupquote{player\_armour}} bzw. \sphinxcode{\sphinxupquote{player\_weapon}} auf die
entsprechende ID gesetzt (mittels der \sphinxcode{\sphinxupquote{\#define}}\sphinxhyphen{}Aliase)


\chapter{Anhang}
\label{\detokenize{appendix:anhang}}\label{\detokenize{appendix::doc}}

\section{Anhang 1: Skript zum konvertieren von schwarz\sphinxhyphen{}weiß Bildern zu c++ Bitmaps}
\label{\detokenize{appendix:anhang-1-skript-zum-konvertieren-von-schwarz-weisz-bildern-zu-c-bitmaps}}
Das Ausführen des folgenden Skriptes konvertiert alle im selben Ordner
vorhandenen .png Dateien zu c++ Arrays und gibt diese in „bitmaps.txt“ aus.

Vor dem Ausführen muss die Python Bibliothek Pillow über pip installiert
werden.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{PIL} \PYG{k+kn}{import} \PYG{n}{Image}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k}{def} \PYG{n+nf}{convert\PYGZus{}to\PYGZus{}sprite\PYGZus{}bitmap}\PYG{p}{(}\PYG{n}{image}\PYG{p}{,} \PYG{n}{islevel}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{bitmap} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{cur\PYGZus{}row} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

    \PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{pixel} \PYG{o+ow}{in} \PYG{n}{image}\PYG{p}{:}
        \PYG{n}{cur\PYGZus{}row} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{pixel} \PYG{o}{==} \PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{,} \PYG{l+m+mi}{255}\PYG{p}{,} \PYG{l+m+mi}{255}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{index} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

        \PYG{k}{if} \PYG{n}{index} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{:}
            \PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}
            \PYG{k}{if} \PYG{n}{islevel}\PYG{p}{:}
                \PYG{n}{bitmap}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cur\PYGZus{}row}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{bitmap}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{cur\PYGZus{}row}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} reverse row, bitmaps are drawn in reverse}
            \PYG{n}{cur\PYGZus{}row} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}

    \PYG{c+c1}{\PYGZsh{} convert string with bits to hexadecimal (\PYGZsq{}10011\PYGZsq{} \PYGZhy{}\PYGZgt{} 0x13)}
    \PYG{n}{bitmap} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{hex}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{num} \PYG{o+ow}{in} \PYG{n}{bitmap}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} make sure redundant zeros are present (0x7 \PYGZhy{}\PYGZgt{} 0x07)}
    \PYG{n}{bitmap} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0x0}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n}{num}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3} \PYG{k}{else} \PYG{n}{num} \PYG{k}{for} \PYG{n}{num} \PYG{o+ow}{in} \PYG{n}{bitmap}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} convert list to nicely styled line}
    \PYG{n}{bitmap} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{bitmap}\PYG{p}{)}
    \PYG{n}{bitmap} \PYG{o}{=} \PYG{n}{bitmap}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{bitmap}

\PYG{c+c1}{\PYGZsh{} get all .png files in current directory}
\PYG{n}{files} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{listdir}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{files} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{level}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n+nb}{file}\PYG{p}{)} \PYG{k}{for} \PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n}{files} \PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.png}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n+nb}{file}\PYG{p}{]}


\PYG{c+c1}{\PYGZsh{} convert and print bitmaps of images to bitmaps.txt}
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bitmaps.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{output\PYGZus{}file}\PYG{p}{:}
    \PYG{k}{for} \PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n}{files}\PYG{p}{:}
        \PYG{n}{image} \PYG{o}{=} \PYG{n}{Image}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n+nb}{file}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{pixels} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{image}\PYG{o}{.}\PYG{n}{getdata}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

        \PYG{n}{bitmap} \PYG{o}{=} \PYG{n}{convert\PYGZus{}to\PYGZus{}sprite\PYGZus{}bitmap}\PYG{p}{(}\PYG{n}{pixels}\PYG{p}{,} \PYG{n+nb}{file}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} format bitmap so that it\PYGZsq{}s ready to be copy\PYGZhy{}pasted directly}
        \PYG{k}{if} \PYG{n+nb}{file}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{output\PYGZus{}file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{static unsigned char level\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{file}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{bitmap} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{output\PYGZus{}file}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{static unsigned char sprite\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{file}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{[]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{bitmap} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{;}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}



\renewcommand{\indexname}{Stichwortverzeichnis}
\printindex
\end{document}